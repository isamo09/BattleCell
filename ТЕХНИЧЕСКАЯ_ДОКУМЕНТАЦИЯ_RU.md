# BattleCell Security - Техническая документация

## Содержание
1. [Обзор](#обзор)
2. [Архитектура](#архитектура)
3. [Модель безопасности](#модель-безопасности)
4. [Процесс шифрования](#процесс-шифрования)
5. [Схема базы данных](#схема-базы-данных)
6. [API endpoints](#api-endpoints)
7. [Frontend компоненты](#frontend-компоненты)
8. [Функции безопасности](#функции-безопасности)
9. [Устойчивость к ошибкам](#устойчивость-к-ошибкам)
10. [Развертывание](#развертывание)

## Обзор

BattleCell Security - это безопасное приложение для хранения паролей и файлов, построенное на Flask, с трехуровневой системой шифрования, защитой мастер-паролем и безопасной обработкой файлов.

### Ключевые возможности
- **Трехуровневая система шифрования**: Серверный ключ + случайный ключ шифрования + мастер-пароль
- **Случайные ключи шифрования**: Уникальный 256-байтный ключ для каждого пользователя
- **Клиентское шифрование**: Все данные шифруются перед сохранением
- **Безопасное хранение файлов**: Зашифрованная загрузка/скачивание файлов
- **Генератор паролей**: Встроенная генерация безопасных паролей
- **Устойчивость к ошибкам**: Graceful handling ошибок дешифровки
- **Progressive Web App**: PWA возможности с поддержкой офлайн режима
- **Современный UI**: Темно-прозрачный дизайн с адаптивной версткой

## Архитектура

### Технологический стек
- **Backend**: Flask (Python)
- **База данных**: SQLite с зашифрованным хранением
- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)
- **Шифрование**: Cryptography library (Fernet + PBKDF2)
- **Аутентификация**: Flask-Login
- **PWA**: Service Worker, Web App Manifest

### Системная архитектура
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Backend       │    │   База данных   │
│   (Браузер)     │◄──►│   (Flask)       │◄──►│   (SQLite)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
    ┌─────────┐            ┌─────────┐            ┌─────────┐
    │Шифрование│            │Управление│            │Зашифрованное│
    │(Клиент) │            │сессиями │            │хранение │
    └─────────┘            └─────────┘            └─────────┘
```

### Структура проекта
```
BattleCell/
├── app.py                 # Основное Flask приложение
├── requirements.txt       # Зависимости Python
├── README.md             # Документация проекта
├── TECHNICAL_DOCUMENTATION_EN.md # Техническая документация (EN)
├── ТЕХНИЧЕСКАЯ_ДОКУМЕНТАЦИЯ_RU.md # Техническая документация (RU)
├── database.db           # SQLite база данных (создается автоматически)
├── uploads/              # Папка для загрузок (создается автоматически)
├── templates/            # HTML шаблоны
│   ├── base.html         # Базовый шаблон
│   ├── index.html        # Главная страница
│   ├── dashboard.html    # Дашборд пользователя
│   ├── passwords.html    # Управление паролями
│   ├── files.html        # Файловое хранилище
│   ├── generator.html    # Генератор паролей
│   ├── settings.html     # Настройки пользователя
│   ├── login.html        # Страница входа
│   ├── register.html     # Страница регистрации
│   ├── error.html        # Страница ошибок
│   └── offline.html      # Страница офлайн режима
└── static/               # Статические файлы
    ├── css/
    │   ├── style.css     # Основные стили
    │   ├── fonts.css     # Стили шрифтов
    │   └── fontawesome.min.css # FontAwesome
    ├── js/
    │   ├── main.js       # Основной JavaScript
    │   └── sw.js         # Service Worker
    ├── fonts/            # Шрифты
    ├── icons/            # Иконки приложения
    └── manifest.json     # PWA манифест
```

## Модель безопасности

### Трехуровневая архитектура безопасности

1. **Серверный уровень безопасности**
   - Серверный ключ шифрования для защиты ключей пользователей
   - Изоляция данных между пользователями
   - Защита от несанкционированного доступа

2. **Уровень случайных ключей шифрования**
   - Уникальный 256-байтный ключ для каждого пользователя
   - Шифрование серверным ключом
   - Хранение в отдельной таблице `encryption_keys`

3. **Уровень мастер-пароля**
   - Отдельный мастер-пароль для шифрования данных
   - Вывод ключа PBKDF2 (200,000 итераций)
   - Шифрование пользовательского ключа мастер-паролем

4. **Шифрование данных**
   - Клиентское шифрование перед передачей
   - AES-256 шифрование через Fernet
   - Уникальные ключи шифрования для каждого пользователя

## Процесс шифрования

### Этап 1: Регистрация пользователя
1. **Ввод данных**: Пользователь вводит имя пользователя и пароль
2. **Хеширование пароля**: Пароль хешируется с помощью bcrypt
3. **Создание аккаунта**: Данные сохраняются в таблице users
4. **Генерация ключа шифрования**: Создается 256-байтный случайный ключ
5. **Шифрование ключа**: Ключ шифруется серверным ключом
6. **Сохранение**: Зашифрованный ключ сохраняется в таблице encryption_keys

### Этап 2: Настройка мастер-пароля
1. **Ввод мастер-пароля**: Пользователь создает мастер-пароль
2. **Генерация пользовательского ключа**: Создается 512-байтный случайный ключ
3. **Вывод мастер-ключа**: PBKDF2 с 200,000 итераций
4. **Шифрование пользовательского ключа**: Ключ шифруется мастер-паролем
5. **Сохранение**: Зашифрованный ключ сохраняется в базе данных

### Этап 3: Сохранение паролей
1. **Ввод данных**: Пользователь вводит данные пароля и мастер-пароль
2. **Проверка мастер-пароля**: Верификация мастер-пароля
3. **Получение ключа шифрования**: Дешифровка ключа шифрования серверным ключом
4. **Шифрование данных**: Данные пароля шифруются ключом шифрования
5. **Сохранение**: Зашифрованные данные сохраняются в базе данных

### Этап 4: Получение паролей
1. **Запрос данных**: Пользователь запрашивает пароль с мастер-паролем
2. **Проверка мастер-пароля**: Верификация мастер-пароля
3. **Получение ключа шифрования**: Дешифровка ключа шифрования серверным ключом
4. **Получение данных**: Извлечение зашифрованных данных из базы
5. **Расшифровка**: Расшифровка данных ключом шифрования
6. **Возврат**: Возврат расшифрованных данных пользователю

### Этап 5: Хранение файлов
1. **Выбор файла**: Пользователь выбирает файл для загрузки
2. **Ввод мастер-пароля**: Пользователь вводит мастер-пароль
3. **Проверка размера**: Проверка размера файла (максимум 500MB)
4. **Чтение файла**: Чтение данных файла в память
5. **Шифрование**: Шифрование данных файла ключом шифрования
6. **Сохранение**: Сохранение зашифрованных данных в базе

## Схема базы данных

### Таблица Encryption Keys
```sql
CREATE TABLE encryption_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER UNIQUE NOT NULL,
    username TEXT NOT NULL,
    encryption_key BLOB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Таблица Users
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username_encrypted BLOB NOT NULL,
    password_hash TEXT NOT NULL,
    master_password_hash TEXT,
    user_key BLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Таблица Passwords
```sql
CREATE TABLE passwords (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    title_encrypted BLOB NOT NULL,
    username_encrypted BLOB NOT NULL,
    password_encrypted BLOB NOT NULL,
    url_encrypted BLOB,
    notes_encrypted BLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Таблица Files
```sql
CREATE TABLE files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    filename_encrypted BLOB NOT NULL,
    original_filename_encrypted BLOB NOT NULL,
    file_size INTEGER NOT NULL,
    encrypted_data BLOB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Таблица User Settings
```sql
CREATE TABLE user_settings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

## API Endpoints

### Endpoints аутентификации
- `GET /` - Главная страница
- `GET /register` - Страница регистрации
- `POST /register` - Регистрация пользователя
- `GET /login` - Страница входа
- `POST /login` - Аутентификация пользователя
- `GET /logout` - Выход пользователя

### Endpoints дашборда
- `GET /dashboard` - Дашборд пользователя
- `GET /passwords` - Страница управления паролями
- `GET /files` - Страница файлового хранилища
- `GET /generator` - Генератор паролей
- `GET /settings` - Настройки пользователя

### Endpoints управления паролями
- `POST /set_master_password` - Установка мастер-пароля
- `POST /add_password` - Добавление нового пароля
- `POST /get_password/<id>` - Получение пароля
- `POST /edit_password/<id>` - Редактирование пароля
- `POST /delete_password/<id>` - Удаление пароля

### Endpoints управления файлами
- `POST /upload_file` - Загрузка зашифрованного файла
- `POST /download_file/<id>` - Скачивание расшифрованного файла
- `POST /delete_file/<id>` - Удаление файла

### Endpoints настроек
- `GET /settings` - Страница настроек
- `POST /change_username` - Изменение имени пользователя
- `POST /change_password` - Изменение пароля аккаунта
- `POST /change_master_password` - Изменение мастер-пароля
- `POST /delete_account` - Удаление аккаунта

## Frontend компоненты

### Система модальных окон
- **Модальное окно добавления пароля**: Форма для добавления новых паролей
- **Модальное окно просмотра пароля**: Проверка мастер-пароля для просмотра
- **Модальное окно редактирования пароля**: Двухэтапный процесс редактирования
- **Модальное окно удаления пароля**: Проверка пароля аккаунта для удаления
- **Модальное окно загрузки файла**: Выбор файла и мастер-пароль
- **Модальное окно скачивания файла**: Проверка мастер-пароля для скачивания
- **Модальное окно удаления файла**: Проверка пароля аккаунта для удаления

### JavaScript функции
- `showAddPasswordModal()` - Отображение формы добавления пароля
- `editPassword(id)` - Инициация редактирования пароля
- `loadPasswordForEdit()` - Загрузка данных пароля для редактирования
- `savePasswordEdit()` - Сохранение отредактированного пароля
- `deletePassword(id)` - Инициация удаления пароля
- `confirmDeletePassword()` - Подтверждение удаления пароля
- `uploadFile()` - Обработка загрузки файла
- `downloadFile(id)` - Инициация скачивания файла
- `deleteFile(id)` - Инициация удаления файла

### PWA возможности
- **Service Worker**: Офлайн функциональность и кэширование
- **Web App Manifest**: Установка как приложение
- **Страница офлайн**: Graceful обработка офлайн режима
- **Иконки приложения**: Различные размеры для разных устройств

## Функции безопасности

### Безопасность паролей
- **Пароль аккаунта**: Хеширование Bcrypt (12 раундов)
- **Мастер-пароль**: Хеширование Bcrypt + вывод PBKDF2
- **Пользовательский ключ**: 512-байтный случайный ключ
- **Ключ шифрования**: 256-байтный случайный ключ
- **Шифрование данных**: AES-256 через Fernet

### Безопасность сессий
- **Таймаут сессии**: Настраиваемая продолжительность сессии
- **Безопасные куки**: HttpOnly, Secure флаги
- **Защита от CSRF**: Токены на основе форм

### Безопасность файлов
- **Безопасные имена файлов**: Werkzeug secure_filename
- **Ограничения размера**: Максимальный размер файла 500MB
- **Квоты хранения**: Ограничения хранения для каждого пользователя
- **Зашифрованное хранение**: Все данные файлов зашифрованы

### Валидация входных данных
- **Защита от SQL-инъекций**: Параметризованные запросы
- **Защита от XSS**: Экранирование выходных данных
- **Проверка типа файлов**: Проверка MIME-типа
- **Проверка размера**: Клиентская и серверная проверка

## Устойчивость к ошибкам

### Обработка ошибок дешифровки
- **Graceful degradation**: Отображение ошибок вместо падения приложения
- **Информативные сообщения**: Понятные описания ошибок для пользователя
- **Совместимость**: Поддержка старой и новой структуры базы данных
- **Восстановление**: Автоматическое восстановление после ошибок

### Глобальная обработка ошибок
```python
@app.errorhandler(500)
def internal_error(error):
    return render_template('error.html', error='Внутренняя ошибка сервера'), 500

@app.errorhandler(404)
def not_found_error(error):
    return render_template('error.html', error='Страница не найдена'), 404

@app.errorhandler(Exception)
def handle_exception(e):
    return render_template('error.html', error=f'Произошла ошибка: {str(e)}'), 500
```

### Обработка ошибок дешифровки данных
- **Пароли**: Отображение "[Ошибка дешифровки]" вместо пропуска записи
- **Файлы**: Отображение имени файла с ошибкой дешифровки
- **Настройки**: Использование значений по умолчанию при ошибках
- **Логирование**: Запись ошибок для диагностики

### Обратная совместимость
- **Схема базы данных**: Поддержка старых незашифрованных столбцов
- **Миграция**: Автоматическая миграция со старой на новую структуру
- **Fallback**: Graceful fallback к старым именам столбцов
- **Смешанные данные**: Обработка смешанных старых/новых структур данных

## Детали шифрования

### Серверный ключ шифрования
```python
SERVER_ENCRYPTION_KEY = b'supercell-server-key-2024-secure-encryption-system'
```

### Генерация ключа шифрования
```python
def generate_encryption_key():
    return secrets.token_bytes(256)
```

### Создание ключа шифрования пользователя
```python
def create_user_encryption_key(user_id, username):
    encryption_key = generate_encryption_key()
    server_fernet = Fernet(base64.urlsafe_b64encode(SERVER_ENCRYPTION_KEY[:32]))
    encrypted_key = server_fernet.encrypt(encryption_key)
    # Сохранение в базу данных
    return encryption_key
```

### Получение дешифрованного ключа шифрования
```python
def get_decrypted_encryption_key(user_id):
    encrypted_key = get_user_encryption_key(user_id)
    if not encrypted_key:
        return None
    server_fernet = Fernet(base64.urlsafe_b64encode(SERVER_ENCRYPTION_KEY[:32]))
    decrypted_key = server_fernet.decrypt(encrypted_key)
    return decrypted_key
```

### Шифрование данных
```python
def encrypt_data(data, user_id):
    encryption_key = get_decrypted_encryption_key(user_id)
    if not encryption_key:
        raise ValueError("Ключ шифрования не найден")
    fernet_key = base64.urlsafe_b64encode(encryption_key[:32])
    f = Fernet(fernet_key)
    encrypted_data = f.encrypt(data.encode() if isinstance(data, str) else data)
    return encrypted_data
```

### Расшифровка данных
```python
def decrypt_data(encrypted_data, user_id):
    encryption_key = get_decrypted_encryption_key(user_id)
    if not encryption_key:
        raise ValueError("Ключ шифрования не найден")
    fernet_key = base64.urlsafe_b64encode(encryption_key[:32])
    f = Fernet(fernet_key)
    decrypted_data = f.decrypt(encrypted_data)
    return decrypted_data
```

## Развертывание

### Требования
- Python 3.8+
- Flask 2.0+
- Cryptography library
- SQLite3
- Современный веб-браузер

### Установка
```bash
# Клонирование репозитория
git clone https://github.com/isamo09/BattleCell
cd BattleCell

# Установка зависимостей
pip install -r requirements.txt

# Инициализация базы данных
python app.py

# Запуск приложения
python app.py
```

### Конфигурация
- **SECRET_KEY**: Установить переменную окружения для продакшена
- **SERVER_ENCRYPTION_KEY**: Хранить в безопасных переменных окружения
- **UPLOAD_FOLDER**: Настроить расположение хранения файлов
- **MAX_CONTENT_LENGTH**: Установить максимальный размер файла
- **База данных**: Настроить путь к базе данных и права доступа

### Рекомендации для продакшена
- **HTTPS**: Включить SSL/TLS шифрование
- **База данных**: Использовать PostgreSQL для продакшена
- **Хранение файлов**: Использовать облачное хранение
- **Логирование**: Реализовать комплексное логирование
- **Мониторинг**: Настроить мониторинг приложения
- **Резервное копирование**: Регулярные резервные копии
- **Серверный ключ**: Хранить в безопасном месте (переменные окружения)

### Чек-лист безопасности
- [ ] Изменить SECRET_KEY по умолчанию
- [ ] Установить безопасный SERVER_ENCRYPTION_KEY
- [ ] Включить HTTPS
- [ ] Настроить безопасные заголовки
- [ ] Настроить ограничение скорости запросов
- [ ] Реализовать аудит логирование
- [ ] Регулярные обновления безопасности
- [ ] Шифрование базы данных в состоянии покоя
- [ ] Шифрование резервных копий

## Производительность

### Оптимизация базы данных
- Индексированные столбцы user_id
- Эффективные паттерны запросов
- Пул соединений для продакшена

### Производительность шифрования
- Итерации PBKDF2 сбалансированы для безопасности/производительности
- Эффективное кэширование ключей
- Минимальные операции перешифрования

### Обработка файлов
- Потоковая загрузка файлов
- Обработка файлов по частям
- Эффективное по памяти шифрование

## Устранение неполадок

### Распространенные проблемы
1. **Ошибки мастер-пароля**: Проверить сложность и длину пароля
2. **Ошибки загрузки файлов**: Проверить размер файла и место на диске
3. **Таймауты сессии**: Настроить конфигурацию сессии
4. **Ошибки базы данных**: Проверить права доступа и целостность базы данных
5. **Ошибки дешифровки**: Проверить целостность ключа шифрования
6. **Проблемы миграции**: Проверить совместимость схемы базы данных

### Режим отладки
```python
app.run(debug=True, host='0.0.0.0', port=5000)
```

### Логирование
- Включить отладочное логирование Flask
- Мониторинг операций базы данных
- Отслеживание ошибок шифрования/дешифрования
- Логирование ошибок дешифровки для диагностики

## Планы развития

### Планируемые функции
- Двухфакторная аутентификация (2FA)
- Анализ силы паролей
- Безопасное совместное использование между пользователями
- Мобильное приложение
- API для интеграции с третьими сторонами
- Расширенное версионирование файлов
- Автоматические резервные копии
- Расширенные PWA возможности

### Улучшения безопасности
- Интеграция с аппаратными модулями безопасности (HSM)
- Расширенное обнаружение угроз
- Поведенческий анализ
- Архитектура с нулевым знанием
- Проверка сквозного шифрования
- Расширенные механизмы восстановления ошибок
- Расширенное аудит логирование
- Мониторинг безопасности в реальном времени

## Безопасность на каждом этапе

### Защита данных в покое
- Все данные зашифрованы в базе данных
- Ключи шифрования зашифрованы серверным ключом
- Пользовательские ключи зашифрованы мастер-паролем
- Пароли хешированы с помощью bcrypt

### Защита данных в движении
- HTTPS для всех соединений
- Безопасные заголовки HTTP
- Защита от CSRF атак

### Защита доступа
- Аутентификация по сессиям
- Проверка мастер-пароля для операций с данными
- Проверка пароля аккаунта для критических операций
- Изоляция данных между пользователями

### Устойчивость к атакам
- Защита от SQL-инъекций через параметризованные запросы
- Защита от XSS через экранирование данных
- Защита от CSRF через токены
- Ограничение размера файлов и запросов
