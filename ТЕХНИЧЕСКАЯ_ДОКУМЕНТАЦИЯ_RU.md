# BattleCell Security - Техническая документация

## Содержание
1. [Обзор](#обзор)
2. [Архитектура](#архитектура)
3. [Модель безопасности](#модель-безопасности)
4. [Процесс шифрования](#процесс-шифрования)
5. [Схема базы данных](#схема-базы-данных)
6. [API endpoints](#api-endpoints)
7. [Frontend компоненты](#frontend-компоненты)
8. [Функции безопасности](#функции-безопасности)
9. [Устойчивость к ошибкам](#устойчивость-к-ошибкам)
10. [Развертывание](#развертывание)

## Обзор

BattleCell Security - это безопасное приложение для хранения паролей и файлов, построенное на Flask, с трехуровневой системой шифрования, защитой мастер-паролем и безопасной обработкой файлов.

### Ключевые возможности
- **Трехуровневая система шифрования**: Серверный ключ + случайный ключ шифрования + мастер-пароль
- **Случайные ключи шифрования**: Уникальный 256-байтный ключ для каждого пользователя
- **Клиентское шифрование**: Все данные шифруются перед сохранением
- **Безопасное хранение файлов**: Зашифрованная загрузка/скачивание файлов
- **Генератор паролей**: Встроенная генерация безопасных паролей
- **Устойчивость к ошибкам**: Graceful handling ошибок дешифровки

## Архитектура

### Технологический стек
- **Backend**: Flask (Python)
- **База данных**: SQLite с зашифрованным хранением
- **Frontend**: HTML5, CSS3, JavaScript (Vanilla)
- **Шифрование**: Cryptography library (Fernet + PBKDF2)
- **Аутентификация**: Flask-Login

### Системная архитектура
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Backend       │    │   База данных   │
│   (Браузер)     │◄──►│   (Flask)       │◄──►│   (SQLite)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
    ┌─────────┐            ┌─────────┐            ┌─────────┐
    │Шифрование│            │Управление│            │Зашифрованное│
    │(Клиент) │            │сессиями │            │хранение │
    └─────────┘            └─────────┘            └─────────┘
```

## Модель безопасности

### Трехуровневая архитектура безопасности

1. **Серверный уровень безопасности**
   - Серверный ключ шифрования для защиты ключей пользователей
   - Изоляция данных между пользователями
   - Защита от несанкционированного доступа

2. **Уровень случайных ключей шифрования**
   - Уникальный 256-байтный ключ для каждого пользователя
   - Шифрование серверным ключом
   - Хранение в отдельной таблице `encryption_keys`

3. **Уровень мастер-пароля**
   - Отдельный мастер-пароль для шифрования данных
   - Вывод ключа PBKDF2 (200,000 итераций)
   - Шифрование пользовательского ключа мастер-паролем

4. **Шифрование данных**
   - Клиентское шифрование перед передачей
   - AES-256 шифрование через Fernet
   - Уникальные ключи шифрования для каждого пользователя

## Процесс шифрования

### Этап 1: Регистрация пользователя
1. **Ввод данных**: Пользователь вводит имя пользователя и пароль
2. **Хеширование пароля**: Пароль хешируется с помощью bcrypt
3. **Создание аккаунта**: Данные сохраняются в таблице users
4. **Генерация ключа шифрования**: Создается 256-байтный случайный ключ
5. **Шифрование ключа**: Ключ шифруется серверным ключом
6. **Сохранение**: Зашифрованный ключ сохраняется в таблице encryption_keys

### Этап 2: Настройка мастер-пароля
1. **Ввод мастер-пароля**: Пользователь создает мастер-пароль
2. **Генерация пользовательского ключа**: Создается 512-байтный случайный ключ
3. **Вывод мастер-ключа**: PBKDF2 с 200,000 итераций
4. **Шифрование пользовательского ключа**: Ключ шифруется мастер-паролем
5. **Сохранение**: Зашифрованный ключ сохраняется в базе данных

### Этап 3: Сохранение паролей
1. **Ввод данных**: Пользователь вводит данные пароля и мастер-пароль
2. **Проверка мастер-пароля**: Верификация мастер-пароля
3. **Получение ключа шифрования**: Дешифровка ключа шифрования серверным ключом
4. **Шифрование данных**: Данные пароля шифруются ключом шифрования
5. **Сохранение**: Зашифрованные данные сохраняются в базе данных

### Этап 4: Получение паролей
1. **Запрос данных**: Пользователь запрашивает пароль с мастер-паролем
2. **Проверка мастер-пароля**: Верификация мастер-пароля
3. **Получение ключа шифрования**: Дешифровка ключа шифрования серверным ключом
4. **Получение данных**: Извлечение зашифрованных данных из базы
5. **Расшифровка**: Расшифровка данных ключом шифрования
6. **Возврат**: Возврат расшифрованных данных пользователю

### Этап 5: Хранение файлов
1. **Выбор файла**: Пользователь выбирает файл для загрузки
2. **Ввод мастер-пароля**: Пользователь вводит мастер-пароль
3. **Проверка размера**: Проверка размера файла (максимум 500MB)
4. **Чтение файла**: Чтение данных файла в память
5. **Шифрование**: Шифрование данных файла ключом шифрования
6. **Сохранение**: Сохранение зашифрованных данных в базе

## Схема базы данных

### Таблица Encryption Keys
```sql
CREATE TABLE encryption_keys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER UNIQUE NOT NULL,
    username TEXT NOT NULL,
    encryption_key BLOB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Таблица Users
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username_encrypted BLOB NOT NULL,
    password_hash TEXT NOT NULL,
    master_password_hash TEXT,
    user_key BLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Таблица Passwords
```sql
CREATE TABLE passwords (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    title_encrypted BLOB NOT NULL,
    username_encrypted BLOB NOT NULL,
    password_encrypted BLOB NOT NULL,
    url_encrypted BLOB,
    notes_encrypted BLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Таблица Files
```sql
CREATE TABLE files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    filename_encrypted BLOB NOT NULL,
    original_filename_encrypted BLOB NOT NULL,
    file_size INTEGER NOT NULL,
    encrypted_data BLOB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Таблица User Settings
```sql
CREATE TABLE user_settings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

## API Endpoints

### Endpoints аутентификации
- `GET /` - Главная страница
- `GET /register` - Страница регистрации
- `POST /register` - Регистрация пользователя
- `GET /login` - Страница входа
- `POST /login` - Аутентификация пользователя
- `GET /logout` - Выход пользователя

### Endpoints управления паролями
- `POST /set_master_password` - Установка мастер-пароля
- `POST /add_password` - Добавление нового пароля
- `POST /get_password/<id>` - Получение пароля
- `POST /edit_password/<id>` - Редактирование пароля
- `POST /delete_password/<id>` - Удаление пароля

### Endpoints управления файлами
- `POST /upload_file` - Загрузка зашифрованного файла
- `POST /download_file/<id>` - Скачивание расшифрованного файла
- `POST /delete_file/<id>` - Удаление файла

### Endpoints настроек
- `GET /settings` - Страница настроек
- `POST /change_username` - Изменение имени пользователя
- `POST /change_password` - Изменение пароля аккаунта
- `POST /change_master_password` - Изменение мастер-пароля
- `POST /delete_account` - Удаление аккаунта

## Функции безопасности

### Безопасность паролей
- **Пароль аккаунта**: Хеширование Bcrypt (12 раундов)
- **Мастер-пароль**: Хеширование Bcrypt + вывод PBKDF2
- **Пользовательский ключ**: 512-байтный случайный ключ
- **Ключ шифрования**: 256-байтный случайный ключ
- **Шифрование данных**: AES-256 через Fernet

### Безопасность файлов
- **Безопасные имена файлов**: Werkzeug secure_filename
- **Ограничения размера**: Максимальный размер файла 500MB
- **Квоты хранения**: Ограничения хранения для каждого пользователя
- **Зашифрованное хранение**: Все данные файлов зашифрованы

## Устойчивость к ошибкам

### Обработка ошибок дешифровки
- **Graceful degradation**: Отображение ошибок вместо падения приложения
- **Информативные сообщения**: Понятные описания ошибок для пользователя
- **Совместимость**: Поддержка старой и новой структуры базы данных
- **Восстановление**: Автоматическое восстановление после ошибок

### Глобальная обработка ошибок
```python
@app.errorhandler(500)
def internal_error(error):
    return render_template('error.html', error='Внутренняя ошибка сервера'), 500

@app.errorhandler(404)
def not_found_error(error):
    return render_template('error.html', error='Страница не найдена'), 404

@app.errorhandler(Exception)
def handle_exception(e):
    return render_template('error.html', error=f'Произошла ошибка: {str(e)}'), 500
```

### Обработка ошибок дешифровки данных
- **Пароли**: Отображение "[Ошибка дешифровки]" вместо пропуска записи
- **Файлы**: Отображение имени файла с ошибкой дешифровки
- **Настройки**: Использование значений по умолчанию при ошибках
- **Логирование**: Запись ошибок для диагностики

## Детали шифрования

### Серверный ключ шифрования
```python
SERVER_ENCRYPTION_KEY = b'supercell-server-key-2024-secure-encryption-system'
```

### Генерация ключа шифрования
```python
def generate_encryption_key():
    return secrets.token_bytes(256)
```

### Создание ключа шифрования пользователя
```python
def create_user_encryption_key(user_id, username):
    encryption_key = generate_encryption_key()
    server_fernet = Fernet(base64.urlsafe_b64encode(SERVER_ENCRYPTION_KEY[:32]))
    encrypted_key = server_fernet.encrypt(encryption_key)
    # Сохранение в базу данных
    return encryption_key
```

### Получение дешифрованного ключа шифрования
```python
def get_decrypted_encryption_key(user_id):
    encrypted_key = get_user_encryption_key(user_id)
    if not encrypted_key:
        return None
    server_fernet = Fernet(base64.urlsafe_b64encode(SERVER_ENCRYPTION_KEY[:32]))
    decrypted_key = server_fernet.decrypt(encrypted_key)
    return decrypted_key
```

### Шифрование данных
```python
def encrypt_data(data, user_id):
    encryption_key = get_decrypted_encryption_key(user_id)
    if not encryption_key:
        raise ValueError("Ключ шифрования не найден")
    fernet_key = base64.urlsafe_b64encode(encryption_key[:32])
    f = Fernet(fernet_key)
    encrypted_data = f.encrypt(data.encode() if isinstance(data, str) else data)
    return encrypted_data
```

### Расшифровка данных
```python
def decrypt_data(encrypted_data, user_id):
    encryption_key = get_decrypted_encryption_key(user_id)
    if not encryption_key:
        raise ValueError("Ключ шифрования не найден")
    fernet_key = base64.urlsafe_b64encode(encryption_key[:32])
    f = Fernet(fernet_key)
    decrypted_data = f.decrypt(encrypted_data)
    return decrypted_data
```

## Развертывание

### Требования
- Python 3.8+
- Flask 2.0+
- Cryptography library
- SQLite3
- Современный веб-браузер

### Установка
```bash
# Клонирование репозитория
git clone <repository-url>
cd supercell

# Установка зависимостей
pip install -r requirements.txt

# Инициализация базы данных
python init_db.py

# Запуск приложения
python app.py
```

### Миграция существующих данных
```bash
# Миграция под новую систему шифрования
python migrate_db.py
```

### Рекомендации для продакшена
- **HTTPS**: Включить SSL/TLS шифрование
- **База данных**: Использовать PostgreSQL для продакшена
- **Хранение файлов**: Использовать облачное хранение
- **Логирование**: Реализовать комплексное логирование
- **Мониторинг**: Настроить мониторинг приложения
- **Резервное копирование**: Регулярные резервные копии
- **Серверный ключ**: Хранить в безопасном месте (переменные окружения)

## Безопасность на каждом этапе

### Защита данных в покое
- Все данные зашифрованы в базе данных
- Ключи шифрования зашифрованы серверным ключом
- Пользовательские ключи зашифрованы мастер-паролем
- Пароли хешированы с помощью bcrypt

### Защита данных в движении
- HTTPS для всех соединений
- Безопасные заголовки HTTP
- Защита от CSRF атак

### Защита доступа
- Аутентификация по сессиям
- Проверка мастер-пароля для операций с данными
- Проверка пароля аккаунта для критических операций
- Изоляция данных между пользователями

### Устойчивость к атакам
- Защита от SQL-инъекций через параметризованные запросы
- Защита от XSS через экранирование данных
- Защита от CSRF через токены
- Ограничение размера файлов и запросов
